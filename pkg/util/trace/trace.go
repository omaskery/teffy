// trace provides opinionated utilities for generating traces
package trace

import (
	"fmt"
	"github.com/omaskery/teffy/pkg/events"
	tio "github.com/omaskery/teffy/pkg/io"
	"io"
	"os"
	"runtime"
	"time"

	"github.com/go-logr/logr"
)

// TracerOption configures the behaviour of a Tracer
type TracerOption = func(t *Tracer)

// ErrorHandler allows client code to observe events that occur within the tracing library
type ErrorHandler = func(err error)

// TimestampFn allows client code to override the mechanism used to generate timestamps for trace events
type TimestampFn = func() int64

// WithLogger provides a logging implementation for the tracing library to report errors and other log events
func WithLogger(logger logr.Logger) TracerOption {
	return func(t *Tracer) {
		t.logger = logger
	}
}

// WithErrorHandler provides a callback for the tracing library to report errors to
func WithErrorHandler(handler ErrorHandler) TracerOption {
	return func(t *Tracer) {
		t.errHandler = handler
	}
}

// WithTimestampFn provides a custom function for generating timestamps for events
func WithTimestampFn(f TimestampFn) TracerOption {
	return func(t *Tracer) {
		t.timestampFn = f
	}
}

// Tracer is an opinionated utility for generating events in Trace Event Format
type Tracer struct {
	stream      tio.EventWriter
	logger      logr.Logger
	errHandler  ErrorHandler
	timestampFn TimestampFn
}

// NewTracer creates a new Tracer that writes its events to the provided EventWriter
func NewTracer(stream tio.EventWriter, options ...TracerOption) *Tracer {
	t := &Tracer{
		stream:      stream,
		timestampFn: MicrosecondTimestampFn,
	}
	for _, opt := range options {
		opt(t)
	}
	return t
}

// TracerToWriter creates a new Tracer that writes its events in JSON Array Format to the provided io.WriteCloser
func TracerToWriter(w io.WriteCloser, options ...TracerOption) *Tracer {
	return NewTracer(tio.NewStreamingWriter(w), options...)
}

// TraceToFile creates a new Tracer that writes events in JSON Array Format to a file specified by the given path
func TraceToFile(path string, options ...TracerOption) (*Tracer, error) {
	f, err := os.OpenFile(path, os.O_RDWR | os.O_CREATE, os.ModePerm)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %w", err)
	}
	return TracerToWriter(f, options...), nil
}

// Close closes the underlying EventWriter that events are written to
func (t *Tracer) Close() error {
	if err := t.stream.Close(); err != nil {
		return fmt.Errorf("error closing stream writer: %w", err)
	}
	return nil
}

// EventOption allows for customising the data in individual events before they are emitted
type EventOption = func(e events.Event)

// WithCategories allows adding category strings to an event, this is supported by all events
func WithCategories(categories ...string) EventOption {
	return func(e events.Event) {
		e.Core().Categories = categories
	}
}

// WithArgs allows for adding arbitrary argument values to an event, note that this is not supported by all events
func WithArgs(args map[string]interface{}) EventOption {
	return func(e events.Event) {
		switch event := e.(type) {
		case events.ArgSetter:
			event.SetArgs(args)
		default:
			panic(fmt.Sprintf("cannot set arguments on this event type: %v", e))
		}
	}
}

// WithStackTrace will attach a stack trace to the event, note that this is not supported by all events
func WithStackTrace() EventOption {
	return func(e events.Event) {
		switch event := e.(type) {
		case events.StackTraceSetter:
			event.SetStackTrace(buildStackTrace())
		default:
			panic(fmt.Sprintf("cannot set stack traces on this event type: %v", e))
		}
	}
}

// WithEndStackTrace will attach a stack trace to the event in the "end" stack trace field, only supported by Complete events
func WithEndStackTrace() EventOption {
	return func(e events.Event) {
		switch event := e.(type) {
		case events.EndStackTraceSetter:
			event.SetEndStackTrace(buildStackTrace())
		default:
			panic(fmt.Sprintf("cannot set end stack traces on this event type: %v", e))
		}
	}
}

func buildStackTrace() *events.StackTrace {
	s := &events.StackTrace{
		Trace: nil,
	}

	// TODO: this probably shouldn't skip a hard coded number of stack levels ¯\_(ツ)_/¯
	stackLevelsToSkip := 5

	pc := make([]uintptr, 10)
	n := runtime.Callers(stackLevelsToSkip, pc)
	if n == 0 {
		return s
	}
	pc = pc[:n]

	frames := runtime.CallersFrames(pc)
	for {
		frame, more := frames.Next()

		s.Trace = append(s.Trace, &events.StackFrame{
			Category: frame.File,
			Name:     fmt.Sprintf("%s:%v", frame.Function, frame.Line),
		})

		if !more {
			break
		}
	}

	return s
}

// Duration is a handle to a Duration generated by BeginDuration, allowing you to signal the end of a Duration
type Duration struct {
	name string
	pid  int64
	t    *Tracer
}

// BeginDuration generates an event signalling the start of some work on a thread
func (t *Tracer) BeginDuration(name string, options ...EventOption) Duration {
	duration := Duration{
		name: name,
		pid:  getPid(),
		t:    t,
	}

	event := &events.BeginDuration{
		EventWithArgs: events.EventWithArgs{
			EventCore: events.EventCore{
				Name:      name,
				Timestamp: t.getTimestamp(),
				ProcessID: &duration.pid,
			},
		},
	}

	t.writeEvent(event, options...)

	return duration
}

// End generates an event signalling the end of some work on a thread
func (d Duration) End(options ...EventOption) {
	event := &events.EndDuration{
		EventWithArgs: events.EventWithArgs{
			EventCore: events.EventCore{
				Name:      d.name,
				Timestamp: d.t.getTimestamp(),
				ProcessID: &d.pid,
			},
		},
	}

	d.t.writeEvent(event, options...)
}

// Instant generates an event with no duration signalling that something happened within the scope of the current thread
func (t *Tracer) Instant(name string, options ...EventOption) {
	t.ScopedInstant(name, events.InstantScopeThread, options...)
}

// ScopedInstant generates an event with no duration signalling that something happened within the specified scope
func (t *Tracer) ScopedInstant(name string, scope events.InstantScope, options ...EventOption) {
	pid := getPid()

	event := &events.Instant{
		EventCore: events.EventCore{
			Name:      name,
			Timestamp: t.getTimestamp(),
			ProcessID: &pid,
		},
		Scope: scope,
	}

	t.writeEvent(event, options...)
}

func (t *Tracer) writeEvent(e events.Event, options ...EventOption) {
	for _, opt := range options {
		opt(e)
	}

	err := t.stream.Write(e)
	if err != nil {
		t.handleError("failed to write begin duration event", err)
	}
}

func (t *Tracer) getTimestamp() int64 {
	return (t.timestampFn)()
}

func (t *Tracer) handleError(context string, err error) {
	if t.logger != nil {
		t.logger.Error(err, context)
	}
	err = fmt.Errorf("%s: %w", context, err)
	if t.errHandler != nil {
		(t.errHandler)(err)
	}
}

// MicrosecondTimestampFn is the default function used to generate timestamps by a Tracer
func MicrosecondTimestampFn() int64 {
	nanoToUs := int64(1e3)
	return time.Now().UTC().UnixNano() / nanoToUs
}

func getPid() int64 {
	return int64(os.Getpid())
}
